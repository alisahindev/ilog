---
description: 
globs: 
alwaysApply: true
---
🧱 MDC Belgesi: ilog
🎯 Amaç (Purpose)
Bu modül, JavaScript/TypeScript projelerinde kullanılmak üzere, özelleştirilebilir, genişletilebilir ve kurumsal ihtiyaçlara uygun bir loglama altyapısı sunmayı amaçlar. Amacımız sadece bilgi yazmak değil, aynı zamanda aşağıdaki yetenekleri sağlamaktır:

Ortak bir logging interface (API) sunmak

Kendi business context’lerini loglara entegre edebilmek

Farklı ortam (dev, test, prod) yapılandırmalarına göre davranış değiştirebilmek

JSON formatında structured log çıktısı üretmek

Async transport'lar (ör. logstash, Sentry, Datadog) entegre edilebilmek

Class ve context bazlı log oluşturulabilmek

🧱 Mimari Yapı (Architecture Overview)
plaintext
Copy
Edit
@yourorg/logger
│
├── core/
│   ├── Logger.ts             → Ana logger class’ı
│   ├── LogLevel.ts           → Log seviyeleri enum
│   ├── LogFormatter.ts       → Log mesajlarını formatlayan sınıf
│   └── LogTransport.ts       → Abstract transport interface
│
├── transports/
│   ├── ConsoleTransport.ts   → console.log wrapper
│   ├── FileTransport.ts      → opsiyonel dosya loglayıcı
│   └── RemoteTransport.ts    → external log servislerine gönderim (opsiyonel)
│
├── context/
│   ├── LogContext.ts         → Request ID, user ID, vs gibi context
│   └── ContextManager.ts     → AsyncLocalStorage ile context yönetimi
│
├── decorators/
│   └── LogMethod.ts          → method log decorator’ı
│
├── index.ts                  → public API girişi
└── types/
    └── index.d.ts            → global type tanımlamaları
    
📦 Kullanılan Teknolojiler
TypeScript: %100 tip güvenliği

AsyncLocalStorage: Context tracking için

ESM/CJS uyumluluğu: Hem Node hem modern bundler desteği

Functional + OOP yapı: Hem class hem functional kullanım mümkün

🔧 Modül Detayları
1. Logger (core/Logger.ts)
ts
Copy
Edit
export class Logger {
  constructor(private options: LoggerOptions);

  info(message: string, meta?: Meta): void;
  warn(message: string, meta?: Meta): void;
  error(message: string, meta?: Meta): void;
  debug(message: string, meta?: Meta): void;

  setContext(context: LogContext): void;
  addTransport(transport: LogTransport): void;
}
2. LogLevel (core/LogLevel.ts)
ts
Copy
Edit
export enum LogLevel {
  DEBUG = 'debug',
  INFO = 'info',
  WARN = 'warn',
  ERROR = 'error',
}
3. LogFormatter (core/LogFormatter.ts)
ts
Copy
Edit
export class LogFormatter {
  static format(level: LogLevel, message: string, meta?: Meta): string;
}
4. LogTransport (core/LogTransport.ts)
ts
Copy
Edit
export interface LogTransport {
  log(level: LogLevel, message: string, context?: LogContext, meta?: Meta): void;
}
5. LogContext & ContextManager
ts
Copy
Edit
export type LogContext = {
  requestId?: string;
  userId?: string;
  businessUnit?: string;
};

export class ContextManager {
  static runWith<T>(context: LogContext, fn: () => T): T;
  static getContext(): LogContext;
}
6. @LogMethod (decorators/LogMethod.ts)
ts
Copy
Edit
export function LogMethod(): MethodDecorator;
Kullanımı:

ts
Copy
Edit
class MyService {
  @LogMethod()
  processOrder() {
    // otomatik log
  }
}
✅ Örnek Kullanım
ts
Copy
Edit
import { Logger, LogLevel, ConsoleTransport, ContextManager } from '@yourorg/logger';

const logger = new Logger({ level: LogLevel.DEBUG });
logger.addTransport(new ConsoleTransport());

ContextManager.runWith({ requestId: 'abc-123', userId: 'user-456' }, () => {
  logger.info('User logged in');
  someBusinessLogic();
});
🧪 Test Planı
 Tüm log seviyeleri test edilecek

 Context isolation (aynı anda farklı async işlemler)

 Transport fallback'ları

 JSON format validasyonu

 Typing coverage (tsc --noEmit + strict)

📁 Yayınlama
npm package: @yourorg/logger

Typescript types: types dizininden otomatik export

ESM + CJS: Rollup ile iki ayrı bundle

README + Usage Examples: Dev dokümantasyonu

🚀 Gelecek Genişletmeler (Future Enhancements)
 Log throttling (burst engelleme)

 Log sampling (ör. %10 debug log)

 OpenTelemetry integration

 JSON Schema validasyonlu structured meta

📌 Notlar
AsyncLocalStorage, yalnızca Node.js 14+ sürümlerde stabil. Eski sürümler için fallback gerekebilir.

Transport’lar async yapılabilir fakat Logger class sync kalmalı (performans ve kontrol açısından).

